'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = provide;
exports.reloadFunctions = reloadFunctions;
exports.reloadProviders = reloadProviders;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _hoistNonReactStatics = require('hoist-non-react-statics');

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _shallowEqual = require('./shallowEqual');

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _getRelevantKeys = require('./getRelevantKeys');

var _getRelevantKeys2 = _interopRequireDefault(_getRelevantKeys);

var _instantiateProvider = require('./instantiateProvider');

var _instantiateProvider2 = _interopRequireDefault(_instantiateProvider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var isServerSide = typeof window === 'undefined';
var allComponentInstances = [];

var contextTypes = {
  providers: _propTypes2.default.object,
  providerInstances: _propTypes2.default.object,
  activeQueries: _propTypes2.default.object,
  queryResults: _propTypes2.default.object,
  partialStates: _propTypes2.default.object,
  forceDeepUpdate: _propTypes2.default.bool
};

function provide(ComponentClass) {
  var _class, _temp;

  if (ComponentClass.ComponentClass) {
    return ComponentClass;
  }

  var componentName = ComponentClass.displayName || ComponentClass.name;

  function getDisplayName() {
    var providers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    return 'Provide' + componentName + '(' + Object.keys(providers).join(',') + ')';
  }

  var Provide = (_temp = _class = function (_Component) {
    _inherits(Provide, _Component);

    _createClass(Provide, [{
      key: 'getChildContext',
      value: function getChildContext() {
        return {
          providers: this.getProviders(),
          providerInstances: this.getProviderInstances(),
          activeQueries: this.getActiveQueries(),
          queryResults: this.getQueryResults(),
          partialStates: this.getPartialStates(),
          forceDeepUpdate: this.forceDeepUpdate
        };
      }
    }, {
      key: 'getProviders',
      value: function getProviders() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

        this.providers = this.providers || props.providers || context.providers || {};

        return this.providers;
      }
    }, {
      key: 'getProviderInstances',
      value: function getProviderInstances() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

        this.providerInstances = this.providerInstances || props.providerInstances || context.providerInstances || {};

        return this.providerInstances;
      }
    }, {
      key: 'getActiveQueries',
      value: function getActiveQueries() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

        this.activeQueries = this.activeQueries || props.activeQueries || context.activeQueries || {};

        return this.activeQueries;
      }
    }, {
      key: 'getQueryResults',
      value: function getQueryResults() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

        this.queryResults = this.queryResults || props.queryResults || context.queryResults || {};

        return this.queryResults;
      }
    }, {
      key: 'getPartialStates',
      value: function getPartialStates() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

        this.partialStates = this.partialStates || props.partialStates || context.partialStates || {};

        return this.partialStates;
      }
    }]);

    function Provide(props, context) {
      _classCallCheck(this, Provide);

      var _this = _possibleConstructorReturn(this, (Provide.__proto__ || Object.getPrototypeOf(Provide)).call(this, props));

      _this.render = isServerSide ? function () {
        var wrappedInstance = _this.getWrappedInstance();

        _this.deinitialize();
        return wrappedInstance;
      } : function () {
        return _this.getWrappedInstance();
      };


      if (!isServerSide && !context.providers) {
        window.rootInstance = _this;
        _this.initializeClientStates(props, context);
      }

      _this.renders = 0;
      _this.componentName = componentName;
      _this.unmounted = true;
      _this.initialize(props, context);
      return _this;
    }

    _createClass(Provide, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.unmounted = isServerSide;
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.unmounted = true;
        this.deinitialize();
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        if (!(0, _shallowEqual2.default)(nextProps, this.props)) {
          this.deinitialize();
          this.initialize(nextProps, this.context);
          this.receivedNewProps = true;
        }
      }
    }, {
      key: 'shouldComponentUpdate',
      value: function shouldComponentUpdate() {
        if (this.forceDeepUpdate || this.context.forceDeepUpdate) {
          return true;
        } else if (this.receivedNewProps) {
          this.receivedNewProps = false;
          return true;
        } else {
          return false;
        }
      }
    }, {
      key: 'update',
      value: function update() {
        if (!this.unmounted) {
          this.forceUpdate();
        }
      }

      // TODO: improve this

    }, {
      key: 'initializeClientStates',
      value: function initializeClientStates() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;
        var _window = window,
            clientStates = _window.clientStates;

        var fauxInstance = this.getFauxInstance(props, context);
        var providers = this.getProviders(props, context);
        var findProvider = function findProvider(props) {
          for (var key in providers) {
            var provider = providers[key];

            if ((0, _getRelevantKeys2.default)(provider.reducers, props).length) {
              if (typeof provider.defaultKey === 'undefined') {
                provider.defaultKey = key;
              }
              if (typeof provider.key === 'undefined') {
                provider.key = provider.defaultKey;
              }

              return provider;
            }
          }
        };

        if (clientStates) {
          for (var providerKey in clientStates) {
            var state = clientStates[providerKey];
            var provider = findProvider(state);

            if (provider) {
              (0, _instantiateProvider2.default)((0, _instantiateProvider.getTempFauxInstance)(fauxInstance, state), provider);
            }
          }
        }
      }
    }, {
      key: 'initialize',
      value: function initialize() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

        var providers = this.getProviders(props, context);

        this.relevantProviders = {};

        for (var key in providers) {
          var provider = providers[key];
          var shouldSubscribe = false;

          if (typeof provider.defaultKey === 'undefined') {
            provider.defaultKey = key;
          }
          if (typeof provider.key === 'undefined') {
            provider.key = provider.defaultKey;
          }

          this.assignActionCreators(props, context, provider);

          if (this.assignReducers(props, context, provider)) {
            shouldSubscribe = true;
          }

          if (this.assignMergers(props, context, provider)) {
            shouldSubscribe = true;
          }

          if (shouldSubscribe) {
            this.subscribeToProvider(props, context, provider);
          }
        }

        this.handleQueries(props, context);
        this.setDisplayName(props, context);

        if (this.doUpdate) {
          this.update();
        }
      }
    }, {
      key: 'deinitialize',
      value: function deinitialize() {
        this.unsubscribe();

        delete this.relevantProviders;
        delete this.componentProps;
        delete this.fauxInstance;
        delete this.subbedAll;
        delete this.query;
        delete this.queryOptions;
        delete this.queries;
        delete this.queriesOptions;
        delete this.subscriptions;
        delete this.mergers;
        delete this.wrappedInstance;
      }
    }, {
      key: 'unsubscribe',
      value: function unsubscribe() {
        var subscriptions = this.getSubscriptions();

        while (subscriptions.length) {
          var unsubscribe = subscriptions.shift();

          unsubscribe();
        }
      }
    }, {
      key: 'setDisplayName',
      value: function setDisplayName(props, context) {
        Provide.displayName = getDisplayName(this.relevantProviders);
      }
    }, {
      key: 'getComponentProps',
      value: function getComponentProps() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

        if (!this.componentProps) {
          this.componentProps = _extends({}, ComponentClass.defaultProps, props, { __wrapper: this
          });

          if (!this.componentProps.ref && ComponentClass.prototype.render) {
            this.componentProps.ref = 'wrappedInstance';
          }
        }

        return this.componentProps;
      }
    }, {
      key: 'getFauxInstance',
      value: function getFauxInstance(props, context) {
        var _this2 = this;

        if (!this.fauxInstance) {
          var componentProps = this.getComponentProps(props, context);

          this.getProviders(props, context);
          this.getProviderInstances(props, context);
          this.getActiveQueries(props, context);
          this.getQueryResults(props, context);
          this.getPartialStates(props, context);
          this.getSubscriptions(props, context);
          this.fauxInstance = _extends({}, Object.getOwnPropertyNames(this).reduce(function (prev, propName) {
            return _extends({}, prev, _defineProperty({}, propName, _this2[propName]));
          }, {}), {
            props: componentProps
          });
        }

        this.fauxInstance.context = context;

        return this.fauxInstance;
      }
    }, {
      key: 'getSubscriptions',
      value: function getSubscriptions() {
        if (!this.subscriptions) {
          this.subscriptions = [];
        }

        return this.subscriptions;
      }
    }, {
      key: 'getMergers',
      value: function getMergers() {
        if (!this.mergers) {
          this.mergers = {};
        }

        return this.mergers;
      }
    }, {
      key: 'getWrappedInstance',
      value: function getWrappedInstance() {
        if (this.context.forceDeepUpdate) {
          this.doUpdate = true;
        }

        if (!this.wrappedInstance || this.doUpdate) {
          this.renders++;
          this.doUpdate = false;
          this.wrappedInstance = _react2.default.createElement(ComponentClass, this.getComponentProps());
        }

        return this.wrappedInstance;
      }
    }, {
      key: 'getProviderInstance',
      value: function getProviderInstance(props, context, provider, getReducerKeys) {
        return (0, _instantiateProvider2.default)({
          fauxInstance: this.getFauxInstance(props, context),
          provider: provider,
          getReducerKeys: getReducerKeys
        });
      }
    }, {
      key: 'assignActionCreators',
      value: function assignActionCreators(props, context, provider) {
        var actionKeys = (0, _getRelevantKeys2.default)(provider.actions, ComponentClass.propTypes);

        if (!actionKeys.length) {
          return false;
        }

        var componentProps = this.getComponentProps(props, context);

        var _getProviderInstance = this.getProviderInstance(props, context, provider, true),
            actionCreators = _getProviderInstance.actionCreators;

        // assign relevant action creators to wrapped component's props


        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = actionKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var actionKey = _step.value;

            if (!props[actionKey]) {
              componentProps[actionKey] = actionCreators[actionKey];
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return true;
      }
    }, {
      key: 'assignReducers',
      value: function assignReducers(props, context, provider) {
        var _this3 = this;

        var reducerKeys = (0, _getRelevantKeys2.default)(provider.reducers, ComponentClass.propTypes);

        if (!reducerKeys.length) {
          return false;
        }

        var getReducerKeys = {};
        var shouldSubscribe = false;

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = reducerKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var reducerKey = _step2.value;

            if (typeof props[reducerKey] === 'undefined') {
              getReducerKeys[reducerKey] = true;
              shouldSubscribe = true;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (!shouldSubscribe) {
          return false;
        }

        var subscriptions = this.getSubscriptions();
        var componentProps = this.getComponentProps(props, context);

        var _getProviderInstance2 = this.getProviderInstance(props, context, provider, getReducerKeys),
            store = _getProviderInstance2.store;

        var state = store.getState();

        // copy the relevant states to the wrapped component's props
        // and whenever some state changes, update (mutate) the wrapped props
        // and raise the `doUpdate` flag to indicate that the component
        // should be updated after the action has taken place

        var _loop = function _loop(reducerKey) {
          componentProps[reducerKey] = state[reducerKey];

          subscriptions.push(store.watch(reducerKey, function (nextState) {
            componentProps[reducerKey] = nextState;
            _this3.doUpdate = true;
          }));
        };

        for (var reducerKey in getReducerKeys) {
          _loop(reducerKey);
        }

        return true;
      }
    }, {
      key: 'assignMergers',
      value: function assignMergers(props, context, provider) {
        var _this4 = this;

        var merge = provider.merge;

        var mergeKeys = (0, _getRelevantKeys2.default)(merge, ComponentClass.propTypes);

        if (!mergeKeys.length) {
          return false;
        }

        var getReducerKeys = {};
        var shouldSubscribe = false;

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = mergeKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var mergeKey = _step3.value;

            if (typeof props[mergeKey] === 'undefined') {
              var merger = merge[mergeKey];

              var _iteratorNormalCompletion5 = true;
              var _didIteratorError5 = false;
              var _iteratorError5 = undefined;

              try {
                for (var _iterator5 = merger.keys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  var reducerKey = _step5.value;

                  getReducerKeys[reducerKey] = true;
                  shouldSubscribe = true;
                }
              } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                  }
                } finally {
                  if (_didIteratorError5) {
                    throw _iteratorError5;
                  }
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        if (!shouldSubscribe) {
          return false;
        }

        var mergers = this.getMergers();
        var subscriptions = this.getSubscriptions();
        var componentProps = this.getComponentProps(props, context);

        var _getProviderInstance3 = this.getProviderInstance(props, context, provider, getReducerKeys),
            store = _getProviderInstance3.store;

        var state = store.getState();

        // some of the wrapped component's props might depend on some state,
        // possibly merged with props and/or context,
        // so we watch for changes to certain `keys`
        // and only update props when those `keys` have changed
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          var _loop2 = function _loop2() {
            var mergeKey = _step4.value;

            if (!props[mergeKey]) {
              (function () {
                var merger = merge[mergeKey];

                componentProps[mergeKey] = merger.get(state, componentProps, context);

                var _iteratorNormalCompletion6 = true;
                var _didIteratorError6 = false;
                var _iteratorError6 = undefined;

                try {
                  for (var _iterator6 = merger.keys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                    var _reducerKey = _step6.value;

                    subscriptions.push(store.watch(_reducerKey, function (nextState) {
                      // we store the merger temporarily so that we may
                      // `get` the value only after the action has completed
                      mergers[mergeKey] = merger;
                      _this4.doMerge = true;
                    }));
                  }
                } catch (err) {
                  _didIteratorError6 = true;
                  _iteratorError6 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
                      _iterator6.return();
                    }
                  } finally {
                    if (_didIteratorError6) {
                      throw _iteratorError6;
                    }
                  }
                }
              })();
            }
          };

          for (var _iterator4 = mergeKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            _loop2();
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        return true;
      }
    }, {
      key: 'subscribeToProvider',
      value: function subscribeToProvider(props, context, provider) {
        var _this5 = this;

        var subscriptions = this.getSubscriptions();

        var _getProviderInstance4 = this.getProviderInstance(props, context, provider),
            store = _getProviderInstance4.store;

        // if any states are relevant, we subscribe to the provider's store;
        // and since we're reflecting any changes to relevant states
        // by mutating `componentProps` and raising the `doUpdate` flag,
        // it's more efficient to simply call `forceUpdate` here


        subscriptions.push(store.subscribe(function () {
          if (_this5.doMerge) {
            var mergers = _this5.getMergers();
            var componentProps = _this5.getComponentProps(props, context);
            var state = store.getState();

            // this is where we `get` any new values which depend on
            // some state, possibly merged with props and/or context
            for (var mergeKey in mergers) {
              var get = mergers[mergeKey].get;

              var value = get(state, componentProps, context);

              if (componentProps[mergeKey] !== value) {
                componentProps[mergeKey] = value;
                _this5.doUpdate = true;
              }

              delete mergers[mergeKey];
            }

            _this5.doMerge = false;
          }

          if (_this5.doUpdate) {
            _this5.handleQueries(props, context);
            _this5.setDisplayName(props, context);
            _this5.update();
          }
        }));
      }
    }, {
      key: 'handleQueries',
      value: function handleQueries(props, context) {
        var _this6 = this;

        var fauxInstance = this.getFauxInstance(props, context);

        return (0, _instantiateProvider.handleQueries)(fauxInstance, function (doUpdate) {
          if (doUpdate) {
            // TODO: should mergers be checked (again) ??
            _this6.doUpdate = true;
            _this6.update();
          }
        });
      }
    }]);

    return Provide;
  }(_react.Component), _class.ComponentClass = ComponentClass, _class.displayName = getDisplayName(), _class.propTypes = contextTypes, _class.contextTypes = contextTypes, _class.childContextTypes = contextTypes, _class.defaultProps = ComponentClass.defaultProps, _temp);

  if (process.env.NODE_ENV !== 'production') {
    var componentInstances = ComponentClass.__componentInstances;

    if (typeof componentInstances === 'undefined') {
      componentInstances = new Set();
      ComponentClass.__componentInstances = componentInstances;
      allComponentInstances.push(componentInstances);
    }

    ComponentClass.Provide = Provide;
    ComponentClass.setComponentClass = function (NextClass) {
      componentInstances = ComponentClass.__componentInstances;
      NextClass.__componentInstances = componentInstances;
      ComponentClass = NextClass;
      Provide.ComponentClass = ComponentClass;
      componentName = ComponentClass.displayName || ComponentClass.name;
    };

    Provide.prototype.componentDidMount = function () {
      this.unmounted = isServerSide;
      componentInstances.add(this);
    };

    Provide.prototype.componentWillUnmount = function () {
      this.unmounted = true;
      this.deinitialize();
      componentInstances.delete(this);
    };

    Provide.prototype.reinitialize = function (props, context, NextClass) {
      var _this7 = this;

      if (NextClass) {
        this.setComponentClass(NextClass);
      }

      setTimeout(function () {
        _this7.doUpdate = true;
        _this7.deinitialize();
        _this7.initialize(props, context);
      });
    };

    Provide.prototype.setComponentClass = function (NextClass) {
      Provide.setComponentClass(NextClass);
      this.componentName = componentName;
    };

    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = undefined;

    try {
      for (var _iterator7 = componentInstances[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
        var componentInstance = _step7.value;
        var props = componentInstance.props,
            context = componentInstance.context;


        componentInstance.reinitialize(props, context, ComponentClass);
      }
    } catch (err) {
      _didIteratorError7 = true;
      _iteratorError7 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion7 && _iterator7.return) {
          _iterator7.return();
        }
      } finally {
        if (_didIteratorError7) {
          throw _iteratorError7;
        }
      }
    }
  }

  return (0, _hoistNonReactStatics2.default)(Provide, ComponentClass);
}

function reloadFunctions(oldFunctions, newFunctions) {
  for (var key in newFunctions) {
    var newFunction = newFunctions[key];
    var oldFunction = oldFunctions[key];

    if (typeof newFunction === 'function' && newFunction.propTypes && !newFunction.Provide && oldFunction && oldFunction.Provide) {
      newFunction.Provide = provide(newFunction);
      oldFunction.setComponentClass(newFunction);
      newFunction.setComponentClass = oldFunction.setComponentClass;

      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = oldFunction.__componentInstances[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var componentInstance = _step8.value;
          var props = componentInstance.props,
              context = componentInstance.context;


          componentInstance.forceDeepUpdate = true;
          componentInstance.reinitialize(props, context, newFunction);
          componentInstance.forceDeepUpdate = false;
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
  }

  if (process.env.NODE_ENV === 'production') {
    console.warn('You should only use `reloadInstances` in development!');
  }
}

function reloadProviders(providers, providerInstances) {
  var _window2 = window,
      rootInstance = _window2.rootInstance,
      clientStates = _window2.clientStates;
  var oldProviders = rootInstance.providers,
      oldProviderInstances = rootInstance.providerInstances;


  for (var key in providers) {
    var provider = providers[key];
    var oldProvider = oldProviders[key];

    if (!providers.replication && oldProvider && oldProvider.replication) {
      provider.replication = oldProvider.replication;
    }
  }

  for (var providerKey in oldProviderInstances) {
    var oldProviderInstance = oldProviderInstances[providerKey];

    if (clientStates) {
      clientStates[providerKey] = oldProviderInstance.store.getState();
    }

    delete oldProviderInstances[providerKey];
  }

  rootInstance.providers = providers;
  rootInstance.providerInstances = providerInstances || oldProviderInstances;
  rootInstance.reinitialize(rootInstance.props, rootInstance.context);

  var _iteratorNormalCompletion9 = true;
  var _didIteratorError9 = false;
  var _iteratorError9 = undefined;

  try {
    for (var _iterator9 = allComponentInstances[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
      var componentInstances = _step9.value;
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = componentInstances[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var componentInstance = _step10.value;
          var props = componentInstance.props,
              context = componentInstance.context;


          if (componentInstance !== rootInstance) {
            context.providers = rootInstance.providers;
            context.providerInstances = rootInstance.providerInstances;
            componentInstance.providers = rootInstance.providers;
            componentInstance.providerInstances = rootInstance.providerInstances;
            componentInstance.reinitialize(props, context);
          }
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10.return) {
            _iterator10.return();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError9 = true;
    _iteratorError9 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion9 && _iterator9.return) {
        _iterator9.return();
      }
    } finally {
      if (_didIteratorError9) {
        throw _iteratorError9;
      }
    }
  }

  if (process.env.NODE_ENV === 'production') {
    console.warn('You should only use `reloadProviders` in development!');
  }
}