(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ReduxReplicate"] = factory();
	else
		root["ReduxReplicate"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.FULLY_INITIALIZED = exports.SET_STATE = exports.STATE_CHANGE_ERROR = exports.REPLICATED_STATE = exports.REPLICATE_STATE = exports.REPLICATED_INITIAL_STATE = exports.REPLICATE_INITIAL_STATE = exports.INITIAL_STATE_ERROR = exports.GOT_INITIAL_STATE = exports.GET_INITIAL_STATE = exports.storeKeysEqual = exports.replicate = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _getInitialState = __webpack_require__(4);

	var _getInitialState2 = _interopRequireDefault(_getInitialState);

	var _performReplication = __webpack_require__(5);

	var _performReplication2 = _interopRequireDefault(_performReplication);

	var _storeKeysEqual = __webpack_require__(2);

	var _storeKeysEqual2 = _interopRequireDefault(_storeKeysEqual);

	var _actionTypes = __webpack_require__(1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Creates a Redux store enhancer designed to replicate actions and states.
	 *
	 * @param {Object} options
	 * @return {Function}
	 * @api public
	 */
	var replicate = function replicate(replication) {
	  return function (next) {
	    return function (reducer, initialState, enhancer) {
	      var store = null;

	      replication = _extends({}, replication);

	      var replicatedReducer = function replicatedReducer(state, action) {
	        var nextState = state;

	        if (action.type === _actionTypes.SET_STATE && !action.mergedState) {
	          if (replication.reducerKeys) {
	            nextState = _extends({}, state, action.nextState);
	          } else {
	            nextState = action.nextState;
	          }

	          // if replication applied multiple times, ensure merge occurs only once
	          action.mergedState = true;
	        }

	        nextState = reducer(nextState, action);

	        if (!action._skipReplication) {
	          (0, _performReplication2.default)(store, replication, state, nextState, action);
	        }

	        return nextState;
	      };

	      store = next(replicatedReducer, initialState, enhancer);

	      if (!store.replication) {
	        store.replication = [];
	      }
	      store.replication.push(replication);

	      if (!store.onReady) {
	        store.readyCallbacks = [];
	        store.onReady = function (readyCallback) {
	          return store.readyCallbacks.push(readyCallback);
	        };
	      }

	      if (typeof replication.key !== 'undefined') {
	        store.key = replication.key;
	      }

	      if (!store.setKey) {
	        store.setKey = function (key, readyCallback) {
	          store.key = key;

	          if (readyCallback) {
	            store.onReady(readyCallback);
	          }

	          store.replication.forEach(function (replication) {
	            (0, _getInitialState2.default)(store, replication);
	          });
	        };
	      }

	      if (!store.setState) {
	        store.setState = function (nextState, _skipReplication, __create) {
	          store.dispatch({
	            type: _actionTypes.SET_STATE,
	            nextState: nextState,
	            _skipReplication: _skipReplication,
	            __create: __create // TODO: clean this up
	          });
	        };
	      }

	      (0, _getInitialState2.default)(store, replication);
	      return store;
	    };
	  };
	};

	exports.default = replicate;
	exports.replicate = replicate;
	exports.storeKeysEqual = _storeKeysEqual2.default;
	exports.GET_INITIAL_STATE = _actionTypes.GET_INITIAL_STATE;
	exports.GOT_INITIAL_STATE = _actionTypes.GOT_INITIAL_STATE;
	exports.INITIAL_STATE_ERROR = _actionTypes.INITIAL_STATE_ERROR;
	exports.REPLICATE_INITIAL_STATE = _actionTypes.REPLICATE_INITIAL_STATE;
	exports.REPLICATED_INITIAL_STATE = _actionTypes.REPLICATED_INITIAL_STATE;
	exports.REPLICATE_STATE = _actionTypes.REPLICATE_STATE;
	exports.REPLICATED_STATE = _actionTypes.REPLICATED_STATE;
	exports.STATE_CHANGE_ERROR = _actionTypes.STATE_CHANGE_ERROR;
	exports.SET_STATE = _actionTypes.SET_STATE;
	exports.FULLY_INITIALIZED = _actionTypes.FULLY_INITIALIZED;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var prefix = "@@redux-replicate";

	var GET_INITIAL_STATE = exports.GET_INITIAL_STATE = prefix + "/GET_INITIAL_STATE";
	var GOT_INITIAL_STATE = exports.GOT_INITIAL_STATE = prefix + "/GOT_INITIAL_STATE";
	var INITIAL_STATE_ERROR = exports.INITIAL_STATE_ERROR = prefix + "/INITIAL_STATE_ERROR";
	var REPLICATE_INITIAL_STATE = exports.REPLICATE_INITIAL_STATE = prefix + "/REPLICATE_INITIAL_STATE";
	var REPLICATED_INITIAL_STATE = exports.REPLICATED_INITIAL_STATE = prefix + "/REPLICATED_INITIAL_STATE";
	var REPLICATE_STATE = exports.REPLICATE_STATE = prefix + "/REPLICATE_STATE";
	var REPLICATED_STATE = exports.REPLICATED_STATE = prefix + "/REPLICATED_STATE";
	var STATE_CHANGE_ERROR = exports.STATE_CHANGE_ERROR = prefix + "/STATE_CHANGE_ERROR";
	var SET_STATE = exports.SET_STATE = prefix + "/SET_STATE";
	var FULLY_INITIALIZED = exports.FULLY_INITIALIZED = prefix + "/FULLY_INITIALIZED";

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var storeKeysEqual = function storeKeysEqual(a, b) {
	  return a === b || a && a.toString && b && b.toString && a.toString() === b.toString();
	};

	exports.default = storeKeysEqual;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = extractReducerKeys;
	function extractReducerKeys(replication, state) {
	  var clientState = replication.clientState;
	  var reducerKeys = replication.reducerKeys;

	  var getReducerKeys = reducerKeys;
	  var setReducerKeys = null;

	  if (reducerKeys === true) {
	    reducerKeys = Object.keys(state);
	    getReducerKeys = reducerKeys;
	  }

	  // here we want the client to get only the undefined initial states
	  if (clientState) {
	    getReducerKeys = [];
	    setReducerKeys = [];

	    if (Array.isArray(reducerKeys)) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = reducerKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var reducerKey = _step.value;

	          if (typeof clientState[reducerKey] === 'undefined') {
	            getReducerKeys.push(reducerKey);
	          } else {
	            setReducerKeys.push(reducerKey);
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    } else {
	      // if reducerKeys is an object, truthy values indicate keys that
	      // can be overridden by the client
	      for (var _reducerKey in reducerKeys) {
	        if (reducerKeys[_reducerKey] && typeof clientState[_reducerKey] === 'undefined') {
	          getReducerKeys.push(_reducerKey);
	        } else {
	          setReducerKeys.push(_reducerKey);
	        }
	      }

	      reducerKeys = Object.keys(reducerKeys);
	    }
	  }

	  replication.reducerKeys = reducerKeys;

	  return { getReducerKeys: getReducerKeys, setReducerKeys: setReducerKeys };
	}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _extractReducerKeys2 = __webpack_require__(3);

	var _extractReducerKeys3 = _interopRequireDefault(_extractReducerKeys2);

	var _storeKeysEqual = __webpack_require__(2);

	var _storeKeysEqual2 = _interopRequireDefault(_storeKeysEqual);

	var _actionTypes = __webpack_require__(1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var getInitialState = function getInitialState(store, replication) {
	  var replicators = [].concat(replication.replicator);
	  var initReplicators = replicators.filter(function (replicator) {
	    if (replicator.onReady) {
	      store.onReady(replicator.onReady);
	    }
	    // just the replicators with `getInitialState`
	    return typeof replicator.getInitialState === 'function';
	  });

	  // need this for multiple replication enhancers
	  store.initializingReplication = (store.initializingReplication || 0) + 1;
	  store.initializedReplication = false;

	  var waitCount = 1;
	  var setInitialState = false;
	  var actualInitialState = replication.reducerKeys ? {} : null;
	  var clear = function clear() {
	    if (--waitCount === 0) {
	      if (setInitialState) {
	        store.setState(actualInitialState, true);
	      }

	      if (--store.initializingReplication === 0) {
	        // all replication enhancers initialized, so we can clear all callbacks
	        while (store.readyCallbacks.length) {
	          store.readyCallbacks.shift()({ store: store });
	        }
	        store.initializedReplication = true;
	        // these are only used during initialization
	        delete replication.create;
	        delete replication.clientState;
	        delete replication.creatorStore;
	        store.dispatch({ type: _actionTypes.FULLY_INITIALIZED });
	      }
	    }
	  };

	  if (!store.key) {
	    clear();
	    return;
	  }

	  var key = store.key;

	  var currentState = store.getState();

	  var shouldReplicate = function shouldReplicate(reducerKey) {
	    return replication.create || replication.clientState && (!reducerKey || typeof replication.clientState[reducerKey] !== 'undefined');
	  };

	  var initState = function initState(_ref) {
	    var getInitialState = _ref.getInitialState,
	        onStateChange = _ref.onStateChange;
	    return function (reducerKey) {
	      var clientState = reducerKey ? replication.clientState && replication.clientState[reducerKey] : replication.clientState;
	      var initProps = {
	        reducerKey: reducerKey,
	        nextState: reducerKey ? currentState[reducerKey] : currentState,
	        queryable: _typeof(replication.queryable) === 'object' ? replication.queryable[reducerKey] : replication.queryable,
	        create: replication.create,
	        clientState: clientState
	      };

	      store.dispatch(_extends({ type: _actionTypes.GET_INITIAL_STATE }, initProps));
	      waitCount++;

	      getInitialState({
	        store: store,
	        reducerKey: reducerKey,
	        clientState: clientState,
	        setState: function setState(state) {
	          if (typeof state === 'undefined') {
	            if (onStateChange && shouldReplicate(reducerKey)) {
	              var action = _extends({ type: _actionTypes.REPLICATE_INITIAL_STATE }, initProps);

	              store.dispatch(action);
	              waitCount++;

	              onStateChange(_extends({}, initProps, {
	                store: store,
	                action: action,
	                setState: function setState(state) {
	                  store.setState(state, true);
	                  store.dispatch(_extends({
	                    type: _actionTypes.REPLICATED_INITIAL_STATE }, initProps, { state: state
	                  }));
	                  clear();
	                },
	                setStatus: function setStatus(status) {
	                  store.dispatch(_extends({
	                    type: _actionTypes.REPLICATED_INITIAL_STATE }, initProps, { status: status
	                  }));
	                  clear();
	                },
	                setError: function setError(error) {
	                  store.dispatch(_extends({
	                    type: _actionTypes.STATE_CHANGE_ERROR }, initProps, { error: error
	                  }));
	                  clear();
	                }
	              }));
	            }
	          } else if ((0, _storeKeysEqual2.default)(key, store.key)) {
	            if (reducerKey) {
	              actualInitialState[reducerKey] = state;
	            } else {
	              actualInitialState = state;
	            }
	            setInitialState = true;
	          }

	          store.dispatch(_extends({ type: _actionTypes.GOT_INITIAL_STATE }, initProps, { state: state }));
	          clear();
	        },
	        setError: function setError(error) {
	          store.dispatch(_extends({ type: _actionTypes.INITIAL_STATE_ERROR }, initProps, { error: error }));
	          clear();
	        }
	      });
	    };
	  };

	  if (replication.reducerKeys) {
	    var _extractReducerKeys = (0, _extractReducerKeys3.default)(replication, currentState),
	        getReducerKeys = _extractReducerKeys.getReducerKeys,
	        setReducerKeys = _extractReducerKeys.setReducerKeys;

	    if (setReducerKeys) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = replicators[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var replicator = _step.value;

	          if (replicator.onStateChange) {
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;

	            try {
	              for (var _iterator2 = setReducerKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                var reducerKey = _step2.value;

	                if (shouldReplicate(reducerKey)) {
	                  (function () {
	                    var setProps = {
	                      reducerKey: reducerKey,
	                      nextState: reducerKey ? currentState[reducerKey] : currentState,
	                      queryable: _typeof(replication.queryable) === 'object' ? replication.queryable[reducerKey] : replication.queryable,
	                      create: replication.create,
	                      clientState: reducerKey ? replication.clientState && replication.clientState[reducerKey] : replication.clientState
	                    };

	                    var action = _extends({ type: _actionTypes.REPLICATE_INITIAL_STATE }, setProps);

	                    store.dispatch(action);
	                    waitCount++;

	                    replicator.onStateChange(_extends({}, setProps, {
	                      store: store,
	                      action: action,
	                      setState: function setState(state) {
	                        store.setState(state, true);
	                        store.dispatch(_extends({
	                          type: _actionTypes.REPLICATED_INITIAL_STATE }, setProps, { state: state
	                        }));
	                        clear();
	                      },
	                      setStatus: function setStatus(status) {
	                        store.dispatch(_extends({
	                          type: _actionTypes.REPLICATED_INITIAL_STATE }, setProps, { status: status
	                        }));
	                        clear();
	                      },
	                      setError: function setError(error) {
	                        store.dispatch(_extends({
	                          type: _actionTypes.STATE_CHANGE_ERROR }, setProps, { error: error
	                        }));
	                        clear();
	                      }
	                    }));
	                  })();
	                }
	              }
	            } catch (err) {
	              _didIteratorError2 = true;
	              _iteratorError2 = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                  _iterator2.return();
	                }
	              } finally {
	                if (_didIteratorError2) {
	                  throw _iteratorError2;
	                }
	              }
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }

	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;

	    try {
	      for (var _iterator3 = initReplicators[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	        var _replicator = _step3.value;

	        var initReducerState = initState(_replicator);

	        var _iteratorNormalCompletion4 = true;
	        var _didIteratorError4 = false;
	        var _iteratorError4 = undefined;

	        try {
	          for (var _iterator4 = getReducerKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	            var _reducerKey = _step4.value;

	            initReducerState(_reducerKey);
	          }
	        } catch (err) {
	          _didIteratorError4 = true;
	          _iteratorError4 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion4 && _iterator4.return) {
	              _iterator4.return();
	            }
	          } finally {
	            if (_didIteratorError4) {
	              throw _iteratorError4;
	            }
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError3 = true;
	      _iteratorError3 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion3 && _iterator3.return) {
	          _iterator3.return();
	        }
	      } finally {
	        if (_didIteratorError3) {
	          throw _iteratorError3;
	        }
	      }
	    }
	  } else {
	    var _iteratorNormalCompletion5 = true;
	    var _didIteratorError5 = false;
	    var _iteratorError5 = undefined;

	    try {
	      for (var _iterator5 = initReplicators[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	        var _replicator2 = _step5.value;

	        initState(_replicator2)();
	      }
	    } catch (err) {
	      _didIteratorError5 = true;
	      _iteratorError5 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion5 && _iterator5.return) {
	          _iterator5.return();
	        }
	      } finally {
	        if (_didIteratorError5) {
	          throw _iteratorError5;
	        }
	      }
	    }
	  }

	  clear();
	};

	exports.default = getInitialState;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _actionTypes = __webpack_require__(1);

	var actionTypes = _interopRequireWildcard(_actionTypes);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	var REPLICATE_STATE = actionTypes.REPLICATE_STATE,
	    REPLICATED_STATE = actionTypes.REPLICATED_STATE,
	    STATE_CHANGE_ERROR = actionTypes.STATE_CHANGE_ERROR;


	var actionTypeValueMap = {};
	for (var key in actionTypes) {
	  actionTypeValueMap[actionTypes[key]] = true;
	}

	var performReplication = function performReplication(store, replication, state, nextState, action) {
	  if (replication.creatorStore && actionTypeValueMap[action.type]) {
	    // TODO: we need a better way to create + replicate
	    replication.creatorStore.dispatch(action);
	  }

	  if (!store || !store.key || !store.initializedReplication) {
	    return;
	  }

	  var replicators = [].concat(replication.replicator);

	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = replicators[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var replicator = _step.value;

	      if (replicator.onStateChange) {
	        if (replication.reducerKeys) {
	          var _iteratorNormalCompletion2 = true;
	          var _didIteratorError2 = false;
	          var _iteratorError2 = undefined;

	          try {
	            for (var _iterator2 = replication.reducerKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	              var reducerKey = _step2.value;

	              if (state[reducerKey] !== nextState[reducerKey]) {
	                (function () {
	                  var setProps = {
	                    reducerKey: reducerKey,
	                    state: state[reducerKey],
	                    nextState: nextState[reducerKey],
	                    queryable: _typeof(replication.queryable) === 'object' ? replication.queryable[reducerKey] : replication.queryable,
	                    create: action.__create // TODO: clean this up
	                    ? function (state) {
	                      return setTimeout(function () {
	                        store.setState(state, true);
	                        store.dispatch(_extends({
	                          type: REPLICATED_STATE }, setProps, { state: state
	                        }));
	                      });
	                    } : false
	                  };

	                  setTimeout(function () {
	                    // not liking this at all, but it should be ok given that
	                    // 99.9999% of data sources are async anyway
	                    store.dispatch(_extends({ type: REPLICATE_STATE }, setProps));
	                  });

	                  replicator.onStateChange(_extends({}, setProps, {
	                    store: store,
	                    action: action,
	                    setState: function setState(state) {
	                      return setTimeout(function () {
	                        store.setState(state, true);
	                        store.dispatch(_extends({
	                          type: REPLICATED_STATE }, setProps, { state: state
	                        }));

	                        if (action.__callback) {
	                          // TODO: clean this up
	                          action.__callback();
	                        }
	                      });
	                    },
	                    setStatus: function setStatus(status) {
	                      return setTimeout(function () {
	                        store.dispatch(_extends({
	                          type: REPLICATED_STATE }, setProps, { status: status
	                        }));

	                        if (action.__callback) {
	                          // TODO: clean this up
	                          action.__callback();
	                        }
	                      });
	                    },
	                    setError: function setError(error) {
	                      return setTimeout(function () {
	                        store.dispatch(_extends({
	                          type: STATE_CHANGE_ERROR }, setProps, { error: error
	                        }));

	                        if (action.__callback) {
	                          // TODO: clean this up
	                          action.__callback();
	                        }
	                      });
	                    }
	                  }));
	                })();
	              }
	            }
	          } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	              }
	            } finally {
	              if (_didIteratorError2) {
	                throw _iteratorError2;
	              }
	            }
	          }
	        } else if (state !== nextState) {
	          (function () {
	            var setProps = {
	              state: state,
	              nextState: nextState,
	              queryable: replication.queryable,
	              create: action.__create // TODO: clean this up
	              ? function (state) {
	                return setTimeout(function () {
	                  store.setState(state, true);
	                  store.dispatch(_extends({
	                    type: REPLICATED_STATE }, setProps, { state: state
	                  }));
	                });
	              } : false
	            };

	            setTimeout(function () {
	              // not liking this at all, but it should be ok given that
	              // 99.9999% of data sources are async anyway
	              store.dispatch(_extends({ type: REPLICATE_STATE }, setProps));
	            });

	            replicator.onStateChange(_extends({}, setProps, {
	              store: store,
	              action: action,
	              setState: function setState(state) {
	                return setTimeout(function () {
	                  store.setState(state, true);
	                  store.dispatch(_extends({
	                    type: REPLICATED_STATE }, setProps, { state: state
	                  }));

	                  if (action.__callback) {
	                    // TODO: clean this up
	                    action.__callback();
	                  }
	                });
	              },
	              setStatus: function setStatus(status) {
	                return setTimeout(function () {
	                  store.dispatch(_extends({
	                    type: REPLICATED_STATE }, setProps, { status: status
	                  }));

	                  if (action.__callback) {
	                    // TODO: clean this up
	                    action.__callback();
	                  }
	                });
	              },
	              setError: function setError(error) {
	                return setTimeout(function () {
	                  store.dispatch(_extends({
	                    type: STATE_CHANGE_ERROR }, setProps, { error: error
	                  }));

	                  if (action.__callback) {
	                    // TODO: clean this up
	                    action.__callback();
	                  }
	                });
	              }
	            }));
	          })();
	        }
	      }

	      if (replicator.postReduction) {
	        replicator.postReduction({ store: store, state: state, nextState: nextState, action: action });
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	};

	exports.default = performReplication;

/***/ })
/******/ ])
});
;