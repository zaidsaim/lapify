'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _actionTypes = require('./actionTypes');

var actionTypes = _interopRequireWildcard(_actionTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var REPLICATE_STATE = actionTypes.REPLICATE_STATE,
    REPLICATED_STATE = actionTypes.REPLICATED_STATE,
    STATE_CHANGE_ERROR = actionTypes.STATE_CHANGE_ERROR;


var actionTypeValueMap = {};
for (var key in actionTypes) {
  actionTypeValueMap[actionTypes[key]] = true;
}

var performReplication = function performReplication(store, replication, state, nextState, action) {
  if (replication.creatorStore && actionTypeValueMap[action.type]) {
    // TODO: we need a better way to create + replicate
    replication.creatorStore.dispatch(action);
  }

  if (!store || !store.key || !store.initializedReplication) {
    return;
  }

  var replicators = [].concat(replication.replicator);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = replicators[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var replicator = _step.value;

      if (replicator.onStateChange) {
        if (replication.reducerKeys) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = replication.reducerKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var reducerKey = _step2.value;

              if (state[reducerKey] !== nextState[reducerKey]) {
                (function () {
                  var setProps = {
                    reducerKey: reducerKey,
                    state: state[reducerKey],
                    nextState: nextState[reducerKey],
                    queryable: _typeof(replication.queryable) === 'object' ? replication.queryable[reducerKey] : replication.queryable,
                    create: action.__create // TODO: clean this up
                    ? function (state) {
                      return setTimeout(function () {
                        store.setState(state, true);
                        store.dispatch(_extends({
                          type: REPLICATED_STATE }, setProps, { state: state
                        }));
                      });
                    } : false
                  };

                  setTimeout(function () {
                    // not liking this at all, but it should be ok given that
                    // 99.9999% of data sources are async anyway
                    store.dispatch(_extends({ type: REPLICATE_STATE }, setProps));
                  });

                  replicator.onStateChange(_extends({}, setProps, {
                    store: store,
                    action: action,
                    setState: function setState(state) {
                      return setTimeout(function () {
                        store.setState(state, true);
                        store.dispatch(_extends({
                          type: REPLICATED_STATE }, setProps, { state: state
                        }));

                        if (action.__callback) {
                          // TODO: clean this up
                          action.__callback();
                        }
                      });
                    },
                    setStatus: function setStatus(status) {
                      return setTimeout(function () {
                        store.dispatch(_extends({
                          type: REPLICATED_STATE }, setProps, { status: status
                        }));

                        if (action.__callback) {
                          // TODO: clean this up
                          action.__callback();
                        }
                      });
                    },
                    setError: function setError(error) {
                      return setTimeout(function () {
                        store.dispatch(_extends({
                          type: STATE_CHANGE_ERROR }, setProps, { error: error
                        }));

                        if (action.__callback) {
                          // TODO: clean this up
                          action.__callback();
                        }
                      });
                    }
                  }));
                })();
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        } else if (state !== nextState) {
          (function () {
            var setProps = {
              state: state,
              nextState: nextState,
              queryable: replication.queryable,
              create: action.__create // TODO: clean this up
              ? function (state) {
                return setTimeout(function () {
                  store.setState(state, true);
                  store.dispatch(_extends({
                    type: REPLICATED_STATE }, setProps, { state: state
                  }));
                });
              } : false
            };

            setTimeout(function () {
              // not liking this at all, but it should be ok given that
              // 99.9999% of data sources are async anyway
              store.dispatch(_extends({ type: REPLICATE_STATE }, setProps));
            });

            replicator.onStateChange(_extends({}, setProps, {
              store: store,
              action: action,
              setState: function setState(state) {
                return setTimeout(function () {
                  store.setState(state, true);
                  store.dispatch(_extends({
                    type: REPLICATED_STATE }, setProps, { state: state
                  }));

                  if (action.__callback) {
                    // TODO: clean this up
                    action.__callback();
                  }
                });
              },
              setStatus: function setStatus(status) {
                return setTimeout(function () {
                  store.dispatch(_extends({
                    type: REPLICATED_STATE }, setProps, { status: status
                  }));

                  if (action.__callback) {
                    // TODO: clean this up
                    action.__callback();
                  }
                });
              },
              setError: function setError(error) {
                return setTimeout(function () {
                  store.dispatch(_extends({
                    type: STATE_CHANGE_ERROR }, setProps, { error: error
                  }));

                  if (action.__callback) {
                    // TODO: clean this up
                    action.__callback();
                  }
                });
              }
            }));
          })();
        }
      }

      if (replicator.postReduction) {
        replicator.postReduction({ store: store, state: state, nextState: nextState, action: action });
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

exports.default = performReplication;